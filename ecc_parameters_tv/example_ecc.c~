/* Example application for ECC primitives */

//#pragma attribute("aid", "f1 00 00 09")
//#pragma attribute("dir", "61 1c 4f 04 f1 00 00 09 50 14 43 52 33 31 32 20 45 43 43 20 50 72 69 6d 69 74 69 76 65 73")

#pragma attribute("aid", "F8 49 52 4D 41 63 61 72 64")
#pragma attribute("dir", "61 15 4F 09 F8 49 52 4D 41 63 61 72 64 50 08 49 52 4D 41 63 61 72 64")
#pragma attribute("fci", "6F 16 A5 14 10 12 02 01 00 02 01 08 10 0A 0C 05 61 6C 70 68 61 02 01 00")

#include <multos.h>
#include <string.h>
#include <ISO7816.h>

#define DES_encrypt(plain_bytes, plain, cipher, key_bytes, key, mode) \
  __push((unsigned int)(plain_bytes)); \
  __push((void *)(key)); \
  __push((unsigned int)(key_bytes)); \
  __push((void *)(plain)); \
  __push((void *)(cipher)); \
  __code(__PRIM, __PRIM_BLOCK_ENCIPHER_ECB, 0x04, mode);


// Commands
#define CMD_GENPAIR     	0x01
#define CMD_GENSIG		0x02
#define CMD_VERSIG		0x03
#define CMD_ECCDH		0x04
#define CMD_ECCLOAD		0x07
#define MYAPP_CLA       	0x70

// Structures for keys
#define SHORT_KEY_LEN 21
#define BUF_LEN 128

typedef struct
{
	BYTE x[SHORT_KEY_LEN];
	BYTE y[SHORT_KEY_LEN];
} eccShort_public_s;

typedef struct
{
	eccShort_public_s publicKey;
	BYTE privateKey[SHORT_KEY_LEN * 2]; // Double length for DH primitive
} eccShort_s;

// Data from APDU; this is placed at PB[0]
#pragma melpublic
BYTE pub[1];

#pragma melstatic

/*
// p-384

BYTE domainParams[] = {
0x00,											// P-384 Curve, P length is 384 bits
0x30,											// Prime len in bytes
0xCE,0x34,0xEE,0x2F,0xF2,0x9D,0x3E,0x7C,0x39,0xFF,0x66,0xA1,0x88,0xB5,0x05,0x49,
0xFE,0xA5,0xEC,0x16,0xCD,0xC1,0xD5,0xD7,0x2B,0xEF,0xC0,0x36,0x25,0xD4,0x44,0x78,
0x3B,0x00,0xA8,0xFB,0x4A,0xB1,0x26,0x54,0x26,0x56,0x5B,0xCC,0x7C,0x30,0xD4,0x45,	// P
0x2D,0xA4,0x4B,0x6D,0xB7,0xD0,0x5A,0x6F,0xD2,0x92,0x33,0xBF,0x93,0xE9,0x85,0x3C,
0xE1,0xEF,0xE7,0xC2,0x07,0xE7,0xA0,0xD3,0x0B,0x29,0x65,0xEF,0xF3,0xFF,0x90,0xF4,
0x68,0xD0,0xCA,0x44,0x31,0x69,0x93,0xED,0x04,0x66,0x8B,0x3E,0xC2,0x76,0x73,0xF9,	// A
         0x8A,0xD2,0x7E,0xB1,0x97,0x5D,0xC6,0x71,0x25,0x23,0x90,0x94,0xC2,0xAF,0x18,0xFD,
          0xB4,0xC4,0x11,0x0C,0x4C,0x00,0x44,0x81,0x87,0x34,0xDA,0xBF,0xAA,0x77,0x0A,0x4D,
           0x8A,0xFE,0x48,0xDF,0x2D,0xC1,0x3F,0xBD,0xD1,0x41,0x0A,0x1A,0xE2,0x8C,0x6E,0x87,	// B
            0x52,0x2B,0x5C,0xEA,0xA1,0x3D,0x7C,0x24,0x48,0xA1,0x7D,0xF4,0xEC,0xE1,0xE2,0x8F,
             0x0F,0x32,0x99,0x53,0x5D,0x85,0xEC,0xBE,0xCB,0xCA,0x83,0x1B,0xDD,0x98,0x65,0x41,
              0x3C,0x54,0x59,0x6F,0xB8,0x17,0xE2,0x78,0x57,0xE3,0x21,0xAA,0x67,0x50,0x04,0x79,	// Gx
               0x28,0xBD,0xB8,0xDD,0x37,0x0C,0xF4,0x90,0x78,0x45,0x90,0x69,0x1D,0x68,0xB6,0x15,
                0xA3,0x8E,0x6A,0xBB,0x2C,0xEF,0x73,0x09,0xFE,0x33,0x0A,0xF1,0xA8,0x75,0x0B,0x6D,
                 0x3D,0xB2,0xDA,0x29,0xB6,0x99,0xCD,0xE8,0x55,0x16,0xB7,0x60,0xFC,0x5E,0x8D,0xA2,	// Gy
                  0x67,0x1A,0x77,0x17,0xF9,0x4E,0x9F,0x3E,0x1C,0xFF,0xB3,0x50,0xC4,0x5A,0x82,0xA4,
                   0xFF,0x52,0xF6,0x0B,0x66,0xE0,0xEA,0xEB,0x1C,0x35,0x0E,0xD9,0x30,0x7B,0x86,0xD0,
                    0xE5,0x2E,0xFD,0x9D,0xA2,0xB0,0x55,0xA8,0x79,0x43,0x1E,0xAA,0x59,0x79,0x32,0x03,	// N
                     0x02											// H
                     };

*/
//secp192r1
/*
BYTE domainParams[] = {
 0x00 , // Format
 0x18 , // Prime length
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, // P
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC, // A
 0x64,0x21,0x05,0x19,0xE5,0x9C,0x80,0xE7,0x0F,0xA7,0xE9,0xAB,0x72,0x24,0x30,0x49,0xFE,0xB8,0xDE,0xEC,0xC1,0x46,0xB9,0xB1, // B
 0x18,0x8D,0xA8,0x0E,0xB0,0x30,0x90,0xF6,0x7C,0xBF,0x20,0xEB,0x43,0xA1,0x88,0x00,0xF4,0xFF,0x0A,0xFD,0x82,0xFF,0x10,0x12, // Gx
 0x07,0x19,0x2B,0x95,0xFF,0xC8,0xDA,0x78,0x63,0x10,0x11,0xED,0x6B,0x24,0xCD,0xD5,0x73,0xF9,0x77,0xA1,0x1E,0x79,0x48,0x11, // Gy
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x99,0xDE,0xF8,0x36,0x14,0x6B,0xC9,0xB1,0xB4,0xD2,0x28,0x31, // N
 0x01 // H 
};
*/

// secp160r1

BYTE domainParams[] = {
0x00,
0x15,
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0xFF,0xFF,0xFF,
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F,0xFF,0xFF,0xFC,
0x00,0x1C,0x97,0xBE,0xFC,0x54,0xBD,0x7A,0x8B,0x65,0xAC,0xF8,0x9F,0x81,0xD4,0xD4,0xAD,0xC5,0x65,0xFA,0x45,
0x00,0x4A,0x96,0xB5,0x68,0x8E,0xF5,0x73,0x28,0x46,0x64,0x69,0x89,0x68,0xC3,0x8B,0xB9,0x13,0xCB,0xFC,0x82,
0x00,0x23,0xA6,0x28,0x55,0x31,0x68,0x94,0x7D,0x59,0xDC,0xC9,0x12,0x04,0x23,0x51,0x37,0x7A,0xC5,0xFB,0x32,
0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xF4,0xC8,0xF9,0x27,0xAE,0xD3,0xCA,0x75,0x22,0x57,
0x01};


/*
// Curve2213
BYTE domainParams[] = {
0x00,
0x1c,
0x1f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfd,
0x15,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x52,0x17,0x40,0x84,0xFF,
0x14,0x25,0xED,0x09,0x7B,0x42,0x5E,0xD0,0x97,0xB4,0x25,0xED,0x09,0x7B,0x42,0x5E,0xD0,0x97,0xB4,0x25,0xED,0x0B,0xBA,0x94,0x28,0x42,0x79,0x67,
0x0C,0xB4,0x76,0xFE,0x08,0x1B,0x61,0xF5,0x6A,0x60,0xB1,0xD1,0xB3,0x4F,0xB7,0x20,0x7D,0x07,0x2E,0xF2,0x5D,0xAD,0xF3,0x77,0x73,0x10,0x49,0xB0,
0x03,0x64,0x29,0x40,0x4D,0x97,0xE1,0xE2,0x17,0xBA,0xD2,0xE5,0x60,0x1F,0x65,0x51,0xF9,0x5D,0x8F,0xE9,0x48,0x1B,0xD4,0x54,0xD1,0xF3,0xE7,0xB6,
0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF5,0xCD,0x04,0x69,0x5A,0x14,0x5C,0x30,0x67,0xCF,0x4A,0xAE,0x20,0x25,
0x08};
*/
/*
// secpk256

BYTE domainParams[] = {
0x00, // format
0x20, // prime length 
0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, //p
0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC, //a
0x5A,0xC6,0x35,0xD8,0xAA,0x3A,0x93,0xE7,0xB3,0xEB,0xBD,0x55,0x76,0x98,0x86,0xBC,0x65,0x1D,0x06,0xB0,0xCC,0x53,0xB0,0xF6,0x3B,0xCE,0x3C,0x3E,0x27,0xD2,0x60,0x4B, //b
0x6B,0x17,0xD1,0xF2,0xE1,0x2C,0x42,0x47,0xF8,0xBC,0xE6,0xE5,0x63,0xA4,0x40,0xF2,0x77,0x03,0x7D,0x81,0x2D,0xEB,0x33,0xA0,0xF4,0xA1,0x39,0x45,0xD8,0x98,0xC2,0x96, //gx,0x
0x4F,0xE3,0x42,0xE2,0xFE,0x1A,0x7F,0x9B,0x8E,0xE7,0xEB,0x4A,0x7C,0x0F,0x9E,0x16,0x2B,0xCE,0x33,0x57,0x6B,0x31,0x5E,0xCE,0xCB,0xB6,0x40,0x68,0x37,0xBF,0x51,0xF5, //gy
0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xBC,0xE6,0xFA,0xAD,0xA7,0x17,0x9E,0x84,0xF3,0xB9,0xCA,0xC2,0xFC,0x63,0x25,0x51, //r
0x01 //h
};
*/

// General working buffers

// Curve25519 (Weierstrass)

/*BYTE domainParams[] = {
0x00, // format
0x20, // prime length
0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xed,// P
0x2A,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0x98,0x49,0x14,0xA1,0x44,// A
0x7B,0x42,0x5E,0xD0,0x97,0xB4,0x25,0xED,0x09,0x7B,0x42,0x5E,0xD0,0x97,0xB4,0x25,0xED,0x09,0x7B,0x42,0x5E,0xD0,0x97,0xB4,0x26,0x0B,0x5E,0x9C,0x77,0x10,0xC8,0x64,// B
0x72,0x66,0xF8,0x64,0xF7,0x99,0xE0,0xD8,0x19,0x4D,0xFA,0x07,0x1F,0x95,0xAA,0x4D,0x1F,0x29,0xD1,0xDF,0x42,0xD5,0x53,0xB4,0x95,0x0B,0x0F,0xDD,0x9C,0x5D,0x57,0x11,// Gx
0x72,0xFB,0x43,0xCD,0x55,0x68,0xB3,0xB6,0x91,0x20,0x4C,0xA8,0xE6,0xA2,0x93,0x06,0x33,0x71,0x6B,0x80,0xFE,0x7D,0xAD,0xAF,0x91,0xE0,0x72,0x34,0x49,0x91,0xE1,0xF1,// Gy
0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0xDE,0xF9,0xDE,0xA2,0xF7,0x9C,0xD6,0x58,0x12,0x63,0x1A,0x5C,0xF5,0xD3,0xED,// r
0x08 // H
};
*/
/*
// P-224

BYTE domainParams[] = {
0x00, // format
0x1c, // prime length
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,
0xB4,0x05,0x0A,0x85,0x0C,0x04,0xB3,0xAB,0xF5,0x41,0x32,0x56,0x50,0x44,0xB0,0xB7,0xD7,0xBF,0xD8,0xBA,0x27,0x0B,0x39,0x43,0x23,0x55,0xFF,0xB4,
0xB7,0x0E,0x0C,0xBD,0x6B,0xB4,0xBF,0x7F,0x32,0x13,0x90,0xB9,0x4A,0x03,0xC1,0xD3,0x56,0xC2,0x11,0x22,0x34,0x32,0x80,0xD6,0x11,0x5C,0x1D,0x21,
0xBD,0x37,0x63,0x88,0xB5,0xF7,0x23,0xFB,0x4C,0x22,0xDF,0xE6,0xCD,0x43,0x75,0xA0,0x5A,0x07,0x47,0x64,0x44,0xD5,0x81,0x99,0x85,0x00,0x7E,0x34,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x16,0xA2,0xE0,0xB8,0xF0,0x3E,0x13,0xDD,0x29,0x45,0x5C,0x5C,0x2A,0x3D,
0x01,
};
*/
/*
// Curve4417

BYTE domainParams[] = {
0x00, // format
0x20, // prime length
0x07,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf7,
0x04,0x86,0xBE,0x25,0xB3,0x4C,0x80,0x80,0x92,0x2B,0x96,0x92,0x57,0xEE,0xB5,0x4C,0x40,0x4F,0x91,0x4A,0x29,0x06,0x7A,0x55,0x60,0xBB,0x9A,0xEE,0x0B,0xC6,0x7A,0x6D,
0x00,0xE3,0x47,0xA2,0x5B,0xF8,0x75,0xDD,0x2F,0x1F,0x12,0xD8,0xA1,0x03,0x34,0xD4,0x17,0xCC,0x15,0xE7,0x78,0x93,0xA9,0x9F,0x4B,0xF2,0x78,0xCA,0x56,0x30,0x72,0xE6,
0x03,0xBE,0x82,0x1D,0x63,0xD2,0xCD,0x5A,0xFE,0x05,0x04,0xF4,0x52,0xE5,0xCF,0x47,0xA6,0x0A,0x10,0x44,0x69,0x28,0xCE,0xAE,0xCF,0xD5,0x29,0x4F,0x89,0xB4,0x50,0x51,
0x00,0x66,0xFE,0x4E,0x7B,0x8B,0x6F,0xE1,0x52,0xF7,0x43,0x39,0x30,0x29,0xA6,0x1B,0xFB,0x83,0x97,0x47,0xC8,0xFB,0x00,0xF7,0xB2,0x7A,0x68,0x41,0xC0,0x75,0x32,0xA0,
0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF7,0x79,0x65,0xC4,0xDF,0xD3,0x07,0x34,0x89,0x44,0xD4,0x5F,0xD1,0x66,0xC9,0x71,
0x4};
*/

/*
#define CURVE_383187_A	"2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA68FEBE08D"
#define CURVE_383187_B	"4BDA12F684BDA12F684BDA12F684BDA12F684BDA12F684BDA12F684BDA12F684BDA12F684BDA12F684F0D6EE62EDBCA"
#define CURVE_383187_X	"4D089F05073F52D26988EF5B2378E120A85DEDD8A1EFACEA0008B13951B3CDA06D5C0B44C5C1B8AC6DC3E5E1F2BF015D"
#define CURVE_383187_Y	"55AB95F2C81569A8E2EADF7C823B133547094AF055BDB287DF4B89F07F1E187D6FCF17FAFA89375C092463FD3D750C55"
#define CURVE_383187_R	"1000000000000000000000000000000000000000000000000E85A85287A1488ACD41AE84B2B7030446F72088B00A0E21"
#define CURVE_383187_H	"8"
*/

unsigned char ECDSA_SIG[] =  {0x0B,0x28,0x6D,0x6F,0xFC,0xC7,0x8C,0x28,0x6A,0x5D,0xB9,0x15,0xA2,0x7E,0x73,0x30,0xD8,0xF2,0x1D,0xB4,0xBE,0xE1,0x6F,0x01,0x56,0xA9,0x3E,0xF7,0x20,0x0B,0x0F,0x71,0x01,0x96,0x3C,0x71,0x5C,0xDA,0x4B,0x7F,0x7F,0x9D,0x79,0x88,0xDD,0xD7,0xCF,0xA4,0xC1,0xFB,0x33,0xC7,0xB1,0x35,0x1B,0x07,0x0A,0x7D,0xFD,0x33,0x90,0x3D,0xCD,0x56};
unsigned char ECDSA_HASH[] = {0xdb,0xbf,0x44,0x8a,0x24,0x29,0xe3,0x21,0x96,0x44,0x78,0x99,0xec,0x91,0x11,0x03,0xaf,0xc0,0x42,0x9e,0x4c,0xa3,0xcc,0x3d,0x9c,0x24,0xa8,0x3f,0x0c,0xb0,0xdd,0xf0};
/* Curve25591 CA PK */

unsigned char PK_CA[64] = {0x02,0x5D,0x18,0x27,0xDF,0x0D,0x71,0x92,
             0x67,0xB6,0x01,0x50,0x8C,0x9B,0x38,0x1D,
             0xA0,0xA5,0xE8,0x4D,0xAF,0x9A,0x73,0xFB,
             0x2A,0xCF,0x24,0x3B,0x06,0x95,0xDC,0xAB,
             0x20,0x77,0x0E,0x03,0xE1,0x38,0x59,0xBF,
             0x2A,0x15,0xFB,0xDE,0x32,0xBC,0x6C,0x57,
             0x87,0x5F,0x49,0xA7,0xB2,0x51,0x17,0xC4,
             0xAA,0x0E,0x57,0x21,0xFB,0xF5,0xB8,0xE6};

#pragma melsession

eccShort_s eccKeyPair;
unsigned char buffer[128];
unsigned char buffer2[128];

unsigned char key[16];

unsigned char pt[16];
unsigned char ct[16];

// TDES

unsigned char key_tdes[24];

unsigned char pt_tdes[8];
unsigned char ct_tdes[8];


void main(void)
{
	WORD len;
	BOOL genOK;
	BYTE *key;
    BYTE *domain;

  /* Check class in APDU. */
  if (CLA != MYAPP_CLA)
    multosExitSW(ISO7816_SW_CLA_NOT_SUPPORTED);

  /* Decode instruction. */
  switch (INS)
    {
	case CMD_GENPAIR:
	
		if (!CheckCase(2))
			multosExitSW(ISO7816_SW_WRONG_PARAMS);


/*multosAESECBEncipher(pt, ct, 0x10, key);
multosAESECBEncipher(pt, ct, 0x10, key);
multosAESECBEncipher(pt, ct, 0x10, key);
multosAESECBEncipher(pt, ct, 0x10, key);
multosAESECBEncipher(pt, ct, 0x10, key);
*/

/*                        multosTripleDESECBEncipher(pt_tdes, ct_tdes, 0x18, key_tdes);
                        pt_tdes[0]++;
                        
                        multosTripleDESECBEncipher(pt_tdes, ct_tdes, 0x18, key_tdes);
                        pt_tdes[0]++;
                        
                        multosTripleDESECBEncipher(pt_tdes, ct_tdes, 0x18, key_tdes);
                        pt_tdes[0]++;
                        
                        multosTripleDESECBEncipher(pt_tdes, ct_tdes, 0x18, key_tdes);
                        pt_tdes[0]++;

                        multosTripleDESECBEncipher(pt_tdes, ct_tdes, 0x18, key_tdes);
                        pt_tdes[0]++;

                        
                        multosTripleDESECBEncipher(pt_tdes, ct_tdes, 0x18, key_tdes);
                                                pt_tdes[0]++;

                        multosTripleDESECBEncipher(pt_tdes, ct_tdes, 0x18, key_tdes);
                                                pt_tdes[0]++;

                        multosTripleDESECBEncipher(pt_tdes, ct_tdes, 0x18, key_tdes);
                                                pt_tdes[0]++;

                        multosTripleDESECBEncipher(pt_tdes, ct_tdes, 0x18, key_tdes);
                                                pt_tdes[0]++;

                        multosTripleDESECBEncipher(pt_tdes, ct_tdes, 0x18, key_tdes);
                        pt_tdes[0]++;

*/
//multosSecureHash(64, 32, buffer, PK_CA);
//multosAESECBEncipher(key_tdes, ct_tdes, 32, key_tdes);

//multosSHA1 (64, PK_CA, buffer);
//multosSHA1 (64, PK_CA, buffer);
//multosSHA1 (64, PK_CA, buffer);
//multosSHA1 (64, PK_CA, buffer);
//multosSHA1 (64, PK_CA, buffer);

		memset(&eccKeyPair,0,sizeof(eccShort_s));

		// Now generate the required key_tdes pair
		multosEccGenerateKeyPair((BYTE*)&eccKeyPair,(BYTE*)&domainParams, 0x00, &genOK);

		// If generated OK, return the key_tdes pair in public
		if(genOK)
		{
		
		//memcpy(ECDSA_SIG_1, ECDSA_SIG, sizeof(ECDSA_SIG));
		//memcpy(ECDSA_SIG_2, ECDSA_HASH, sizeof(ECDSA_HASH));
		//memcpy(ECDSA_SIG_3, PK_CA, sizeof(PK_CA));
				
			memcpy(pub,(BYTE *)&eccKeyPair,sizeof(eccShort_s));
			La = sizeof(eccShort_s);
			multosExit();
		}
		else
		{
			multosExitSW(0x90FF);
		}

		break;

	case CMD_ECCLOAD:
		if (!CheckCase(3))
			multosExitSW(ISO7816_SW_WRONG_PARAMS);

//		memset(&eccKeyPair,0,sizeof(eccShort_s));

		// Copy provided key_tdespair to buffer
//		memcpy(&eccKeyPair,pub,Lc);

		multosExitSW(ISO7816_SW_NO_ERROR);
		break;

	case CMD_GENSIG:
		if (!CheckCase(3))
			multosExitSW(ISO7816_SW_WRONG_PARAMS);




		// Blank hash buffer
		memset(buffer,0,BUF_LEN);

		// Copy in hash from APDU
		memcpy(buffer,pub,Lc);

		// Blank results buffer
		memset(buffer2,0,BUF_LEN);

		// Do signature - result into public
		multosEccGenerateSignature((BYTE*)&domainParams,(BYTE*)&eccKeyPair.privateKey,buffer,buffer2, 0x00, &genOK);

		if (genOK)
		{
		memcpy(pub,buffer2,2*SHORT_KEY_LEN);
			La = 2*SHORT_KEY_LEN;
			multosExit();
		}
		else
			multosExitSW(0x90FF);
			
		break;

	case CMD_VERSIG:
		if (!CheckCase(3))
			multosExitSW(ISO7816_SW_WRONG_PARAMS);

		// Public contains hash to check (prime length), signature to verify (2*prime length), public key_tdes (2*prime length)
//		multosEccVerifySignature((BYTE*)&domainParams, pub, pub + SHORT_KEY_LEN, pub + (3*SHORT_KEY_LEN), 0x00, &genOK);

          multosEccVerifySignature((unsigned char *)&domainParams, 
                                   (unsigned char *)pub,
                                   (unsigned char *)pub + SHORT_KEY_LEN, 
                                   (unsigned char *)pub + 3*SHORT_KEY_LEN, 
                                   0x00, 
                                   &genOK);


		if(!genOK)
			multosExitSW(0x90FF);
		else
			multosExitSW(ISO7816_SW_NO_ERROR);

		break;

	case CMD_ECCDH:
/*		if (!CheckCase(3))
			multosExitSW(ISO7816_SW_WRONG_PARAMS);

		memset(buffer,0,BUF_LEN);

		// Public starts with the external public key_tdes (2*SHORT_KEY_LEN)
		multosEccDiffieHelman((BYTE*)&domainParams, (BYTE*)&eccKeyPair, pub, buffer, 0x00, &genOK);

		if(!genOK)
			multosExitSW(0x90FE);
		else
		{
			memcpy(pub,buffer,SHORT_KEY_LEN);	
			multosExitLa(SHORT_KEY_LEN);
		}
*/
		break;

    default:
      multosExitSW(ISO7816_SW_INS_NOT_SUPPORTED);
  }
}
