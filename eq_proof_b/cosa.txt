
#define crypto_compute_vPrime2() \
do { \
  /* Clear the buffer, to prevent garbage messing up the computation */\
  __code(CLEARN, public.prove.buffer.data, SIZE_V - 2*SIZE_E); \
  /* Multiply e with least significant half of r_A */\
  __code(PUSHZ, SIZE_E - SIZE_R_A/2); \
  __push(BLOCKCAST(SIZE_R_A/2)(public.prove.rA + SIZE_R_A/2)); \ 
  __push(BLOCKCAST(SIZE_E)(credential_2->signature.e)); \
  __code(PRIM, PRIM_MULTIPLY, SIZE_E); \
  __code(STORE, public.prove.buffer.data + SIZE_V - 2*SIZE_E, 2*SIZE_E); \
  /* Multiply e with most significant half of r_A */\
  __code(PUSHZ, SIZE_E - SIZE_R_A/2); \
  __push(BLOCKCAST(SIZE_R_A/2)(public.prove.rA)); \ 
  __push(BLOCKCAST(SIZE_E)(credential_2->signature.e)); \
  __code(PRIM, PRIM_MULTIPLY, SIZE_E); \
  /* Combine the two multiplications into a single result */\
  __code(ADDN, public.prove.buffer.data, SIZE_V - SIZE_R_A/2); \
  __code(POPN, 2*SIZE_E); \
  /* Subtract from v and store the result in v' */\
  __push(BLOCKCAST(SIZE_V/2 + 1)(credential_2->signature.v + SIZE_V/2)); \
  __push(BLOCKCAST(SIZE_V/2 + 1)(public.prove.buffer.data + SIZE_V/2)); \
  __code(SUBN, SIZE_V/2 + 1); \
  IfCarry( \
    debugMessage("Subtraction with borrow, adding 1"); \
    __code(INCN, public.prove.buffer.data, SIZE_V/2); \
  ); \
  __code(POPN, SIZE_V/2 + 1); \
  __code(STORE, public.prove.buffer.data + SIZE_V/2, SIZE_V/2 + 1); \
  __push(BLOCKCAST(SIZE_V/2)(credential_2->signature.v)); \
  __push(BLOCKCAST(SIZE_V/2)(public.prove.buffer.data)); \
  __code(SUBN, SIZE_V/2); \
  __code(POPN, SIZE_V/2); \
  __code(STORE, public.prove.buffer.data, SIZE_V/2); \
} while (0)
/* Simple subtraction does not fit on the stack.
  __push(BLOCKCAST(SIZE_V)(credential->signature.v)); \
  __push(BLOCKCAST(SIZE_V)(public.prove.buffer.data)); \
  __code(SUBN, SIZE_V); \
  __code(POPN, SIZE_V); \
  __code(STORE, public.prove.buffer.data, SIZE_V); \
} while (0) */

